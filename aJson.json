{
  "article": [
    {
      "id": 0,
      "path": "public/assets/article/飘雪.md",
      "author": "quirkybird",
      "title": "飘雪",
      "categories": "life_blog",
      "descr": "雪花飘落在衣服上，一个身处远方的孩子又在想家。",
      "image": "https://blog.yamorz.top/assets/cover/dsjkfbasdiljfbnasd.webp",
      "create_at": "2024-03-01",
      "content": "时间推回到2002年的第一场雪，我在一声声啼哭中落地。\r\n\r\n后来2004年，刀郎单曲《2002年的第一场雪》红遍大江南北。\r\n\r\n> 2002年的第一场雪，  \r\n 比以往时候来的更晚一些。  \r\n 停靠在八楼的二路汽车，  \r\n 带走了最后一片飘落的黄叶。  \r\n  \r\n......\r\n\r\n配上音乐，有一种被炸裂而出的感觉。\r\n\r\n每当提及2002年，除了我出生，这首歌，还有墙上有两个大胖小子图片的挂历，也是2002年的。\r\n\r\n我和我妹妹都是在大雪天出生的，她只不过晚了两年，何不如说我们与雪有什么缘分呢。\r\n\r\n寒假一开始，大概是腊月中旬了，两个孩子吵吵闹闹的回老家，似乎一刻也待不住，老家像是有什么魔力，疯狂的吸引我们俩。载着回村的摩托车，在蜿蜒的路途上，犹如丝带飘落在山涧，轰鸣声中，记不得转过多少弯，那时候坐摩托总害怕掉下去，手抓着前一个人腰部的衣服。车连着人，在公路上起起伏伏。\r\n\r\n水泥路到了尽头，接下来就是泥路了。一下车，更想冲回家了，我和妹妹往前面冲，冲了一段距离，气喘吁吁，还是慢慢走吧。一直都是上坡路，上山的路，我背着奥特曼书包，我妹妹是白雪公主书包，里面装的是寒假作业，实在累了，路上有专供歇气的石板。停停走走，不一会儿到了家门口。\r\n\r\n两个小脑袋从离家不远的小山坡冒出，一上一下波动，越来越近了，直到露出全身。\r\n\r\n家是土屋，不是院子，土瓦加着土墙。\r\n\r\n我走在前面，突然停住了脚步，妹妹也跟着停了下来，“爷爷”，看到爷爷坐在屋前，叫了一声，妹妹跟着叫了一声，他应了一声，“欸”，随即摇晃着装有寒假作业的书包往家里冲，书包放在屋里，爷爷招呼我们去烤火。\r\n\r\n天冷的很，不烤火是受不了的，用山上拾的干柴在火坑里面架起明火，安逸得很。\r\n\r\n吃完午饭，和爷爷奶奶聊聊学校发生的什么稀奇事，聊着聊着，火坑的明火变成了火红的木炭，燃着，也只能听见“哧哧”木炭燃烧音，爷爷双手抱在怀里，头不停的点，奶奶也是，瞌睡来了，我和妹妹喊一声他们，他们应一声，马上又点着头，过会儿，头趴在腿上，呼噜声也来了。\r\n\r\n到了晚上，早早的犯困了，在火坑里的热灰里埋上几根红薯，过几分钟，用火钳把红薯翻一个面，等感觉熟透了，用火钳夹出来扔在地上，用手去抓，烫的立马缩手，反复放在地上轻轻的拍，把表面多的灰抖掉，在20瓦的灯泡下，我们扒开焦黄的外皮，露出金黄香甜的内瓤，热气腾空而上，消失在电灯照亮在区域外，是黑暗处的屋梁，必须呼呼的吹，吹凉些，烫嘴，烧红薯让心里暖暖的。等吃完红薯，手指、嘴边全部黑乎乎的。洗漱过后，也都干净了，奶奶叫我们洗脚要洗洗膝盖和小腿，走路过后，这样洗洗明天不会感觉酸痛，擦干脚上的水后，爬上床，什么也没想，马上睡过去了。\r\n\r\n木门缝里漏过的风丝儿在屋里打着转儿。\r\n\r\n雪，是雪。一边惊呼一边奔跑，我的记忆中，雪都是偷偷在我睡着时间降落的。\r\n\r\n大雪盖住了小山坡，像是在冬眠了，没了动静，换了个天，眼前的雪花片片飘零，飘得很慢，比雨浪漫多了。下雪的天总是洁白的，像是小姑娘，生怕知道雪花如何形成的，用与雪花相同的颜色覆盖。\r\n\r\n我站在屋檐下，片片雪花从眼前飘过，伸出手，鹿角似的六边形雪花瓣飘落在我手心，放到眼前，晶莹剔透的，不由得感叹细小的精致。不一会儿就融化了。\r\n\r\n火坑一早我爷爷就生起火，站在外面一小会儿冷的瑟瑟发抖，立马钻进屋里烤火，随着变得暖和，心再也压抑不住了，想着，带着我妹妹冲出了屋子，进入到冰雪的童话世界，站在雪地里，我的世界变白了，连眼角的余光都是白茫茫一片。眼下的雪像是白鸭绒洒落在地面，蓬松绵软，想扑进去。这不是我第一次看见雪，也不是最后一次，却显得那么亲切。\r\n\r\n接着又跑回了屋里，拿出洋铲，好家伙终于派上用场了，扛不起来，只好拖着走，在石板上发出“呲呲”响声，拖到雪上时，就没了声响。我示意妹妹蹲在洋铲上面，两只手扶着把，去年下雪天也这样玩过，她很快就坐上去了，小火车开始启动，我背对着拉洋铲把儿，平日里我是拉不动的，只有下雪天。厚雪表面留下洋铲背面的痕迹，沿着田埂，天然的火车轨道，我也想坐在上面开火车，她拉不动我，只好一直我拉，拉也很开心，到了一个小坡，冲刺往下，当然也有失误，力量用的不均匀，翻车了，人栽到雪里，追着我打，我又不是故意的，不亦乐乎。除了白雪，我们的欢声笑语就是当下大地的色彩。\r\n\r\n玩久了，手冻的通红，赶忙拖着洋铲往回赶，红彤彤的手在火上烤，一阵阵刺痛，不一会儿手暖和了，又冲出去玩。\r\n\r\n慢慢的，雪下两天，停一停，又开始下，雪又变得无趣味起来，直到过年。\r\n\r\n爸妈要年前一天才回老家，一直在老家过年，恰好那几天也下了雪。年前一天我早早的起床了，等着爸妈回来，因为也不确定他们什么时候回来，可能是一大早，中午和晚上都有可能，一切都像是平常，人的心态却早已不是昨天，盼着盼着，希望下一秒家里大白狗开始狂吠，顺着家往外的小坡冒出两个头。好了，今天做什么事情都是心不在焉，时不时望望。要吃午饭了，怎么还没回来，心想着吃完饭总该回来了吧，一阵阵，失望而揪心，多的还是期待，弄得我身上也好不自在，在屋跟前上蹿下跳，光线渐渐的暗下来了，还没见着人影。\r\n\r\n开始拿起了作业本写写画画，以此来打发时间，头低着，死盯着本子上的文字。\r\n\r\n突然，大白狗原地叫了两声，沿着小道冲了出去，接着就是我们俩。\r\n\r\n背着背包，背着背篓，提着塑料袋，爸妈回来了，在我期待的那个小坡出现。\r\n\r\n其实也没什么，在乎的是口袋里的零食、什么新奇的玩具、也可能是什么新衣服。最忘不掉的，是套着红色塑料薄膜的一长袋苹果，每一年，刚才那样场景出现时，画面里总有这样一袋苹果，以至于当我闻到苹果味，便会想起那样装着苹果的形式。\r\n\r\n爸妈带给我们的是安稳感，一种说话时底气的安稳，未成熟个体里面总有这样一个人，撑在你后面。\r\n\r\n过年当天，就是在一起煮一顿好吃的，好吃的随你定义，我认为妈妈亲手煮的饭就是好吃的，早上匆忙的一顿饭，至少有一个无论怎样都在关心你的人。放鞭炮、上坟祭祖、去庙里祈祷......，放炮，把炮仗扔在雪堆里，啪！炸出个大窟窿，扔在大人跟前，吓得团团转......\r\n\r\n当天下午，就要去外婆家，都是走路去的，也没有公路，有路也没有车。走以前别人走过的小路，平日里半个小时，过年下大雪，足足要走一个多小时！路不平坦，上坡又下坡，路上还经常摔到，树上的雪一不小心也可能滑落进背心，裤子和鞋子别提，一路过去，全都湿透了。但还是要走，每年都走，外婆早就煮好了一锅好吃的等我们。\r\n\r\n雪啊，每年都要下，而且是过年下，总让我觉着过年是下雪的标志。后来啊，雪下的越来越少，极为不规律，好几次过年都不下雪，没有雪的春节是不是少点什么？\r\n\r\n雪也是奇怪，我随着长大，离家越来越远，回家的时间越来越少，雪也少了，是在等待我回家吗？\r\n\r\n现在我到了离家很远很远的东北念书，去年隆冬一场雪让我开心极了，我在雪地里奔跑，往最深的雪处跑，脸都冻僵了，站在一个高处，大声呼喊，呼喊，呼喊，呼喊却没有回音。\r\n\r\n大雪在我面前下，比我家乡的还大，除了寒冷，没有任何味道。  \r\n![夜雪图](https://picdm.sunbangyan.cn/2023/10/24/6231d6df074d59dcfcd7b72ab2a67970.webp)",
      "update_at": "2024-03-01"
    },
    {
      "id": 1,
      "path": "public/assets/article/那个夏末的正午.md",
      "author": "quirkybird",
      "title": "那个夏末的正午",
      "categories": "life_blog",
      "descr": "那年夏天，一个模模糊糊的身影坐在教室，走后，什么也不剩。",
      "image": "https://blog.yamorz.top/assets/cover/170255837041710220657_65b69c0770.jpeg",
      "create_at": "2024-10-28",
      "content": "考试完的正午，楼道里的同学一哄而散，像蓄满水的池子打开了闸，往外流。顺着人流，走出教室，下了楼梯，一切都那么快。\r\n\r\n踏上走了三年的水泥路，从教学楼到吃饭地儿，一切是那么熟悉，包括花坛里的桂花树。\r\n\r\n尽管是夏日晴天，也像是被什么笼罩了的。吃完午饭的人也从各种饭馆子陆续出来，回了家里。饭店老板们整理着桌子板凳，街道又空了，只剩下太阳光直勾勾的照射在地面上，人也像是细菌，躲着它跑。钻进了奶茶店，拿起了柠檬水，酸甜清爽一下浸透了全身。小摊贩见没人了，也不吆喝，顺着木椅躺下，马上打起了呼噜。\r\n\r\n我习惯考试完回教室睡午觉，刚跨过校门，一辆车从我身边驶过，恰巧是我们任课老师，他没看见我，我也没和他打招呼，汽车碾压水泥路的声音渐渐离我远了，路上剩下我一个人。\r\n\r\n走在水泥路上，不知道是不是穿着运动鞋的缘故，脚上格外的轻，一会儿热一会儿冷的风，从鞋面的网状小孔钻进脚掌，好生舒服。\r\n\r\n透过栅栏，望见了我们教室的位置，对了，为什么会有栅栏，围绕整个操场有栅栏，钢丝裹着塑料皮，交叉成网状，学校一有什么活动，比如开什么大会、运动会，就将栅栏门关着，一个不叫我们出去，一个不叫我们进去，实在搞不懂这样做的目的。\r\n\r\n不知觉的到了一条直道，它离教室也不远了。道的两边都是树，左边挨着池塘是一排柳树，右边则是沙树，围在操场的边缘，体育课后常在它的荫蔽下乘凉。柳树和水总有分不开的联系，公园里面柳树也是，都是栽在水池边，阵阵风吹过，抚摸着池水，泛起涟漪，柳条也因风而起，在风中摇曳，一派生机。\r\n\r\n那样固然好，但也太死板。过年上坟后，我和奶奶走在回家的路上，我见着一个树的枝是软塌塌的，一根一根垂着的，没有叶子，那是我第一次认识柳树。“无心插柳柳成荫”早映在我心中，出于好奇，果断折柳，奶奶折了根较粗壮的枝条，我则是折了细小的，小小的事物总是让人着迷，想着试试有没有那么神奇，无心插柳都成荫，何况我这有心人，奶奶拿出锄头，把柳枝栽在屋子的斜前方，我把柳枝插在一个被割开的塑料瓶，起初，每天观察芽苞，发现果然还是在成长，后面由于回小镇上学，也就忘记这回事了。\r\n\r\n等到下一次回家也是夏日，我塑料瓶里的柳枝早已成了枯条，而我奶奶插的柳枝已经可以乘凉了，在我家门前，微风习习，柳枝飘起。\r\n\r\n缓过神，看向沙树缝隙间的操场，有人影，只不过在操场另一端，那边也是去教学楼的一条路，远处红色的塑胶跑道上滚起阵阵热浪，人影也随浪摇动。听不见脚步声，像画，足球场点缀着人影，走过，接着又有人走，一段时间空了，剩下足球场那基本的画布，不一会儿又有不同的人去触笔。没有声响。\r\n\r\n沉醉在夏日的校园里，又望见桂花树。\r\n\r\n到了，走廊里有同学挪板凳的声响，快步上楼，教室门前的阳台，有位女同学站在阳台处，再走过两步，一道刺眼的光线射入我的眼睛，我下意识的躲闪，是从女同学双手之间发出的，起初以为是照镜子，但光线又不像是明亮的，有些浑浊，再走过两步，一行行文字在我眼前时，那反光的东西面纱终于被揭开了，一本书，书的纸张很好，印刷也很到位。她丝毫没有察觉到我，目光不断地在文字上面扫，像是要把它们都装进脑子里。她的脸浸没在了书反射的光线里，风儿吹动她丝丝短发，扬起又落下。忘却了她穿着这什么样的衣服，也忘了她是谁。\r\n\r\n我还是怕她又看见我，匆匆几步跨进了教室门，回到座位坐下。阳光还在驱赶孩子的脚步，窗外已是白茫茫一片，吓得我急匆匆收回了眼神，怕它给我吸出去。\r\n\r\n发现有同学在教室都睡着了，轻轻的呼噜声在教室也格外响。\r\n\r\n趴在桌子上，我头往前望，盯着黑板，稀稀落落写着考试科目和时间，还有同学搞怪的涂鸦。发着呆，像是在想什么，又什么都没想。\r\n\r\n在窗外树丛里阵阵蝉鸣中，趴着睡着了。\r\n\r\n做了一个很长很长的梦。浩瀚的银河中，有着一颗的蓝色星球，生命始终在时光里面穿梭，哇哇叫的孩子也在读高中了，这是他呆过的一个地方，度过了几年时间。\r\n\r\n不知道谁在我后面推了一把，摔了个跟头，一路在山坡上滚动，起起伏伏，颠颠簸簸。有时候缓了，便停了下来，突然它又将我推了一把，继续向前滚动。\r\n\r\n身体突然一震，我从座位上弹起，口水从嘴里流出，拉出个丝，慌忙的擦拭。\r\n\r\n屋子里闷热，但窗外依然只有蝉鸣和烈日，屋外像是有什么吸引我一样，我大步走出了门，望着操场，楼下已经有挪桌子声响，女同学，女同学也不在阳台站着了。校外的人也陆陆续续往教学楼里走，回到属于自己的位置，他们现在在这里能找到一个小小借用的空间，在学校的时光里插入痕迹，在自己的岁月涂上色彩，一人径直走向我，拍了拍我的肩膀，猛地回过神来。\r\n\r\n人还是飘飘然，总觉世界抛弃了我，在那段时空。教室还是教室，现在我站在这里，几十天后呢，几年后呢，它们迎来新人，似乎都与我无关，我在乎的只是它和我一起经历的日子，发生的故事，可我们又行色匆匆，在的时候想逃离，而后又怀念。记忆总像是录像带，一遍一遍的在脑海放映，慢慢的，录的多了，部分记忆也就丢失了，重新拾起时，难免的感叹。\r\n\r\n那年夏日，我一边做题一边看着窗外，期盼着桂花泛着清香侵袭我的心田，可桂花要秋天才开，但这是我最后一个夏天了。",
      "update_at": "2024-07-22"
    },
    {
      "id": 2,
      "path": "public/assets/article/记录第一次实习感受.md",
      "author": "quirkybird",
      "title": "记录第一次实习感受",
      "categories": "life_blog",
      "descr": "实习开始了，走走停停，还是一个人来到了杭州漂泊。",
      "image": "https://blog.yamorz.top/assets/cover/blog.jfif",
      "create_at": "2024-10-28",
      "content": "很久都没有更新自己的博客了，上次还是我在学校准备期末考试的时候，还记得当时找实习然后马上就是期末考试，现在我已经在实习了，并且已经过了一周时间，聊聊这段时间来的感受吧，说实话很不想这些东西被遗忘，人会经历很多第一次，然后后面慢慢平淡的融入人群，记录起来，以便日后记起曾经发生的这些事，那时候肯定还是很感慨，这是属于我的独属空间，没有多少人浏览，纯粹说说自己想说的，不受多余的约束，是和社交媒体的区别。\r\n\r\n1.11号，结束了我大三上学期的最后一堂考试，回宿舍后，还剩三个同学，彼此做着自己喜欢的事情，没有多少交流，这段时间过后，很少有机会和他们有这么近的距离了，也很少机会有这样的室友关系了，可以说基本结束了我的大学生涯，又怎么不怀念呢，那是高中时期一天一坐就是从早上天黑到晚上10多回家的所追求的东西，尽管现在看来就是那么回事了，也有许多不合理的地方吗，经历了一些，感受了一些。也是跨越了2000多公里，还记得两年前爸妈把我送到学校，在学校外不远的公交站告别后，我鼻子一酸，就开始了大学生活，大学生活总的来讲时间是属于自己的，第一次大学期末考试就让我知道了究竟大学是怎么一回事，我的大学在开发区，平时我就呆在宿舍，一年半的疫情和我大学时光重叠，还记得住在22楼的日子，怎么说呢，都过去了，我们终究是要面向社会的，无论社会是什么样子。  \r\n\r\n在2023的12月底，还是找到了一家前端实习，总共面试了8家，实力不足吧，有几家公司明确说了不合适，只有一家公司问了`CSS`问题，也是奇怪，总体来说，像是事件循环、Promise、跨域、闭包、React 16 和React 15的区别（类组件和函数式组件区别）、Vue2和Vue3的区别、Vue和React的区别、再来就是具体的项目问题。这些我都做过总结的，希望下一次找实习时能把之前的总结用上，特别是面试暴露出来的问题，非常感谢现在公司给我的实习机会，不管怎么说，小公司，一轮面试后，技术总监和HR又开了个会议后就确定了。后面有两家公司我进入二面了，然后就没有然后了，说实话，面试还是有体验感而言的，最离谱的是一个BOSS上面为CEO（老板）的给我面试，直接叫我打开项目完成一个功能，我直接懵逼，虽然后面还是做出来了，在他挂断后的五分钟内，但说什么都晚了，还有一个二面的一个女面试官，全程下来就是给人的感觉就是照着一个单子读问题的，而且信号很差，很长的延迟，我回答完，她半天说一个“嗯”，上面都是一些原因，总体来说，还是自己准备不够充分，对实际开发过程中有些问题想的不是很全面。\r\n\r\n1.13日早晨，宿舍还剩下我和我另一个室友，我小心翼翼的收拾完后，给自己的床位拍了一张照片，拖着行李箱，搭着公交车坐了5个小时站票火车到大兴机场，晚上，18：15的飞机从北京大兴机场飞往杭州萧山机场，第一次坐飞机，什么都是小心翼翼的，严格的安检，让我上抖音把能上飞机的物品查了又查。飞机加速在跑道上冲刺后，很快就到了上空，我坐在56A，望着窗外，我知道我即将开启一段新的旅程，人类的文明将大地点缀，漆黑的夜里泛着光芒，这并不能证明人类的伟大，相反对地球其它生物是很大的威胁，暂时不思考这些了。\r\n\r\n杭州，无感。一周的实习生活打开了我生命的另一个维度，上班仔，早上9：20到11：45，休息到1：00，晚上18：15下班，对于大部分上班人来说，时间算是短的，国内工作时长太长了，尽管法律不是那么规定的，培训一天后，安装完开发环境，丢给我一个UI稿，有十几张原型图，这一周都在忙着切图，不涉及任何的数据请求和上传，项目很急，但压力不会给到一个刚入职的实习生，使用蚂蚁开源的Umi框架，算是学习到了约定式路由，具体他们配置路由和菜单跳转的映射关系，400多行代码，我没看懂。一周写了大概7，8个页面，加上几个弹窗，表格是别人高度封装好的，只需要传入参数即可。讲讲工作体验，首先是办公室工作不太适应，从学校到职场，前两天都是蒙的，我每次到一个新地方的老毛病。写代码多亏对面工位老哥，很多不会的东西都问他，他总会说不会没关系，目前为止我还没接触整个开发流程，只是自己开一个分支写代码，后面他会在我的代码上添加数据请求那些东西，接下来好好努力吧，适应办公环境。\r\n\r\n接下来，又会发生什么呢？",
      "update_at": "2024-03-01"
    },
    {
      "id": 4,
      "path": "public/assets/article/Figma初体验.md",
      "author": "quirkybird",
      "title": "Figma初体验",
      "categories": "life_blog",
      "descr": "我是页面切图仔，当然要学会切图工具啦",
      "image": "https://blog.yamorz.top/assets/cover/figma1.webp",
      "create_at": "2024-10-28",
      "content": "![figma](https://server.yamorz.top/image/figma1.webp)\r\n\r\n> 当今 UI 设计软件: Sketch、Adobe XD、即时设计\r\n\r\n**插一条新闻**，2022 年 9 月 15 日，[美国软件公司宣布以约 200 亿美元收购 Figma](https://news.adobe.com/news/news-details/2022/Adobe-to-Acquire-Figma/default.aspx)，好好好，打不过就收购是吧\r\n\r\n别说这么多，快来用用看(搓手)，开始切图:hammer:，作为初次体验，先来切一个 Apple Store 页面\r\n\r\n等等，可能需要一些前置工作，以获得切图的最佳体验，由于方便性，直接使用网页版操作\r\n\r\n- 安装[字体插件](https://www.figma.com/downloads/)（以获得系统自带的所有字体，桌面版软件可忽略）\r\n- 选择性安装中文字体浏览器插件 ([figma 中文社区](https://www.figma.cool/))\r\n- 安装 avatar 头像生成插件\r\n\r\n学习到的点：\r\n\r\n- 基础：点击一个组件，右侧可以查看和调整尺寸、字体等信息，多选可以按住 shift+点击需要选中元素\r\n- 添加辅助线： 左上角 Figma 图标 -> view -> Rulers（shift + R），然后屏幕出现了像素标尺，从最左边或者最上面拖动- 可以分别显示垂直和水平辅助线\r\n- 显示组件距离：选中一个组件后，按住 Alt，鼠标移动到其它组件，可以查看相对位置\r\n- 快速复制：选中一个组件后按住 Alt，鼠标按住该元素拖动，就可以复制该组件\r\n- 插件使用: 右键 -> plugins -> 点击插件名称 -> 等待响应\r\n- 使用蒙版实现遮罩：复制一个底部组件，将上面的组件和该组件归为一个组（选中后右键 -> Group selection(ctrl + G)），然后将右键该组内底部组件 -> use as mask(ctrl + alt + M)，即可完成蒙版设置，超出底部组件部分将不会显示（熟悉 PS 的同学都知道，蒙版这个功能超级强大，[如何使用 PS 蒙版](https://www.zhihu.com/question/62042775)）\r\n\r\n> one hour later...\r\n\r\n![apple store](https://server.yamorz.top/image/X-1.png)\r\n\r\n使用感受：第一次上手，感觉还不错，如果对熟悉使用 PS 等软件的人更加方便，因为之前没使用过其它类似软件的缘故，所以也不好比较他们之间的差异，不过大众选择出来的产品，一定有它独特的优势\r\n\r\n后续我将持续学习 Figma，尝试更高级的功能和炫酷的效果\r\n\r\n> 相关链接： [酸梅干超人的电话亭](https://space.bilibili.com/393337657)\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 5,
      "path": "public/assets/article/TCP三次握手和四次挥手简析.md",
      "author": "quirkybird",
      "title": "TCP三次握手和四次挥手简析",
      "categories": "tech_blog",
      "descr": "TCP建立连接和断开连接经历哪些过程",
      "image": "https://blog.yamorz.top/assets/cover/1701687151781TCP-1.png",
      "create_at": "2024-10-28",
      "content": "## TCP 三次握手\r\n\r\n1. 客户端向服务器发起建立 tcp 连接请求，等待服务器确认\r\n2. 服务器收到客户端连接请求，向客户端发送确认连接信息\r\n3. 客户端收到连接确认信息后，向服务器发送最后的确认请求，双方完成连接\r\n\r\n对应图析：\r\n![tcp三次握手](https://pic1.zhimg.com/v2-8ce8c897b4d5e7397b25eb4d4b31d7fc_r.jpg)\r\n\r\n## TCP 四次挥手\r\n\r\n1. tcp 客户端向 tcp 服务端发起关闭 tcp 连接请求，表示没有数据发往服务端了\r\n2. tcp 服务端收到关闭请求，并发送给客户端同意关闭信息\r\n3. 等待服务端把剩余的数据传给客户端后，服务端发起关闭连接\r\n4. 客户端收到关闭连接后，发送确认关闭连接消息，服务端连接关闭，客户端等待 2MSL 的时间后没有收到回复后，关闭连接\r\n\r\n> 参考文章：\r\n>\r\n> - [一文彻底搞懂 TCP 三次握手、四次挥手过程及原理](https://zhuanlan.zhihu.com/p/108504297)\r\n> - [深入浅出 TCP 四次挥手 （多图详解）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5406f75d0ee4738810e1689b3ee0b81~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 6,
      "path": "public/assets/article/useContext结合useReducer管理状态.md",
      "author": "quirkybird",
      "title": "useContext结合useReducer管理状态",
      "categories": "tech_blog",
      "descr": "主要就是利用`useContext`可以沿着组件向下传值，且无需考虑层级，和`useReducer`中Reducer用于管理状态",
      "image": "https://blog.yamorz.top/assets/cover/1703492528822useContext和useReducer管理状态.png",
      "create_at": "2024-10-28",
      "content": "![React](https://i.imgur.com/gk2rI9R.png)\r\n> 本文参考React官方文档:[使用 Reducer 和 Context 拓展你的应用](https://react.docschina.org/learn/scaling-up-with-reducer-and-context)，区别于useState，更好的管理复杂的状态\r\n\r\n主要就是利用`useContext`可以沿着组件向下传值，且无需考虑层级，和`useReducer`中Reducer用于管理状态\r\n## 第一步：创建Context\r\n```js\r\nimport { createContext } from 'react';\r\n\r\nexport const TasksContext = createContext(null);\r\nexport const TasksDispatchContext = createContext(null);\r\n```\r\n## 第二步：将state和dispatch函数放入context\r\n```js\r\nimport { TasksContext, TasksDispatchContext } from './TasksContext.js';\r\n\r\nexport default function TaskApp() {\r\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\r\n  // ...\r\n  return (\r\n    <TasksContext.Provider value={tasks}>\r\n      <TasksDispatchContext.Provider value={dispatch}>\r\n        ...\r\n      </TasksDispatchContext.Provider>\r\n    </TasksContext.Provider>\r\n  );\r\n}\r\n```\r\n## 第三步：在组件树中的任何地方使用 context\r\n现在你不需要任何沿着组件树一层层传递状态和修改状态逻辑，只需要使用state和dispatch，一切变得简单起来  \r\n\r\n```js\r\nexport default function TaskList() {\r\n  const tasks = useContext(TasksContext);\r\n  // ...\r\n```\r\n\r\n```js\r\nexport default function AddTask() {\r\n  const [text, setText] = useState('');\r\n  const dispatch = useContext(TasksDispatchContext);\r\n  // ...\r\n  return (\r\n    // ...\r\n    <button onClick={() => {\r\n      setText('');\r\n      dispatch({\r\n        type: 'added',\r\n        id: nextId++,\r\n        text: text,\r\n      });\r\n    }}>Add</button>\r\n    // ...\r\n```\r\n## 第四步：让我们把所有东西放到一个文件（非必须，但我推荐这样做）\r\n此时，我们已经完成了随传随用随改变，不过我们的state仍然在最顶层组件`TaskApp`提供，我们试着将整个状态逻辑抽离出去，单独一个文件管理这些状态，显然这是我们想要的，代码模块更加独立\r\n我们连接所有，让那个文件具有这些功能：  \r\n1. 它将管理 reducer 的状态。  \r\n2. 它将提供现有的 context 给组件树。  \r\n3. 它将 把 children 作为 prop，所以你可以传递 JSX。  \r\n\r\n```js\r\nimport { createContext } from 'react';\r\n//此处可以导入Reducer，初始状态值\r\n\r\nexport const TasksContext = createContext(null);\r\nexport const TasksDispatchContext = createContext(null);\r\n//封装组件\r\nexport function TasksProvider({ children }) {\r\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\r\n\r\n  return (\r\n    <TasksContext.Provider value={tasks}>\r\n      <TasksDispatchContext.Provider value={dispatch}>\r\n        {children}\r\n      </TasksDispatchContext.Provider>\r\n    </TasksContext.Provider>\r\n  );\r\n}\r\n```\r\n现在我们一个文件来提供这所有关于状态的一切，使用时不用担心数据混乱，逻辑疯狂抽离让我们代码更好管理维护，让组件的作用更加明确单一，是一个好代码的标准之一，平时写代码要注意它们。\r\n\r\n> 文档细节参考(useContext,useReducer)：  \r\n> - [迁移状态逻辑至 Reducer 中](https://react.docschina.org/learn/extracting-state-logic-into-a-reducer)  \r\n> - [使用 Context 深层传递参数](https://react.docschina.org/learn/passing-data-deeply-with-context)",
      "update_at": "2024-03-01"
    },
    {
      "id": 7,
      "path": "public/assets/article/tailwindcss实现滑动按钮.md",
      "author": "quirkybird",
      "title": "tailwindcss实现滑动按钮",
      "categories": "tech_blog",
      "descr": "重点的地方就是利用`peer-checked`,根据兄弟类的状态来调整样式",
      "image": "https://blog.yamorz.top/assets/cover/1702909216331滑动按钮.png",
      "create_at": "2024-10-28",
      "content": "> tailwindcss 强大的功能让我们无需 JS 实现滑动按钮效果\r\n\r\n直接上代码,其中中间圆形按钮是通过伪元素`::before`实现，重点的地方就是利用`peer-checked`,根据兄弟类的状态来调整样式\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <title>tailwindcss实现滑动按钮</title>\r\n  </head>\r\n\r\n  <script src=\"https://cdn.tailwindcss.com\"></script>\r\n  <body class=\"p-20\">\r\n    <div className=\"\">tailwindcss实现滑动按钮</div>\r\n    <div class=\"mt-5\">\r\n      <label class=\"relative inline-block w-16 h-9 rounded-full\">\r\n        <input type=\"checkbox\" class=\"peer opacity-0 w-0 h-0\" />\r\n        <span\r\n          class=\"absolute cursor-pointer top-0 left-0 right-0 bottom-0 bg-gray-300 rounded-full\r\n duration-300 before:content-[''] before:absolute before:w-7 before:h-7 before:bottom-1 before:left-1\r\n before:rounded-full before:bg-white before:duration-300 peer-checked:before:translate-x-7 peer-checked:bg-blue-500\"\r\n        ></span>\r\n      </label>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n看看效果，大概就是这样\r\n\r\n<iframe height=\"403.2000427246094\" style=\"width: 100%;\" scrolling=\"no\" title=\"tailwindcss实现滑动按钮\" src=\"https://codepen.io/ye-qin/embed/VwgoxEJ?default-tab=result&theme-id=dark\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href=\"https://codepen.io/ye-qin/pen/VwgoxEJ\">\r\n  tailwindcss实现滑动按钮</a> by ye qin (<a href=\"https://codepen.io/ye-qin\">@ye-qin</a>)\r\n  on <a href=\"https://codepen.io\">CodePen</a>.\r\n</iframe>\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 8,
      "path": "public/assets/article/React实现路由和组件懒加载.md",
      "author": "quirkybird",
      "title": "React实现路由和组件懒加载",
      "categories": "tech_blog",
      "descr": "对于 React 老手来说，哈？懒加载都不会，学啥 React 嘛，不过对于看文档学习 React 来实现自己的博客来说",
      "image": "https://blog.yamorz.top/assets/cover/1703316470364react.png",
      "create_at": "2024-10-28",
      "content": "> 对于 React 老手来说，哈？懒加载都不会，学啥 React 嘛，不过对于看文档学习 React 来实现自己的博客来说，懒加载路由和组件咱也没想过要使用，这或许就是看视频和自己翻文档学习的差别，视频会有别人使用该技术的最佳实践，自己就瞎琢磨吧\r\n\r\n让笔者想起这个问题的原因是参加一个公司的前端实习面试，面试官问我：React 实现路由懒加载？  \r\n我回答:使用 require()，传入一个箭头函数，里面导入组件（💦💦💦，当时的想法是咱也没在 React 项目里面使用过路由懒加载啊，只是记得 Vue3 中是使用`() => import()`做的，哪怕是回答一个`import()`也比 require()强啊，现在想想尴尬极了，怪不得当时面试官只是疑问的说 require?然后淡淡的“嗯”，直接下一个问题）\r\n\r\n尴尬归尴尬啊，咱们要从中汲取经验，这就来给自己的 yamorz 站点加一个路由懒加载，下次再问咱们可就不怕了 😎😎😎\r\n\r\n通过文档很快就可以解决这个问题，主要就是使用到 React 的一个 API -> `lazy`\r\n\r\n这个属性可以完成路由懒加载和组件懒加载，我们先说路由懒加载，其实就是用`lazy`包裹一个返回 Promise 的函数，返回一个 React 组件具体来说就是：\r\n\r\n```js\r\nimport { lazy } from \"react\";\r\n\r\nconst Blog = lazy(() => import(\"./components/Blog\"));\r\n```\r\n\r\n接下来我们需要用`Suspense`组件来处理懒加载路由暂时还没加载时的应急处理，本身应该是白屏，React 给出了以下错误：\r\n\r\n> A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\r\n\r\n我们不使用`startTransition`,使用刚刚提到的`Suspense`组件（启用了 Suspense 的路由在默认情况下会将导航更新包装至 transition 中），由于我们使用 React Router v6 中的`createBrowserRouter`, 包裹在渲染用的`<Outlet />`即可\r\n\r\n```js\r\nimport { Suspense } from \"react\";\r\nimport { Outlet } from \"react-router-dom\";\r\n\r\n<Suspense fallback={<Loading />}>\r\n  <Outlet />\r\n</Suspense>;\r\n```\r\n\r\n如此设置之后，路由加载时，处于暂停状态，将显示`<Loading />`，至此，路由懒加载完成\r\n\r\n接下来在演示一下如何实现组件懒加载，其实开始我还有一个疑惑，组件懒加载没必要啊，我是用条件渲染不就可以控制组件是否渲染吗 ❓ 查了一下才知道，原来就算是条件渲染 React 也会执行未渲染的代码，造成性能问题，特别是需要加载一个相对较大的组件时\r\n举一个组件懒加载的小例子：\r\n\r\n```js\r\nimport { lazy, Suspense, useState } from \"react\";\r\nimport Loading from \"./components/common/Loading\";\r\n\r\nconst MyComponent = lazy(() => import(\"./component/MyComponent\"));\r\n\r\nconst App = () => {\r\n  const [isShow, setIsShow] = useState(false);\r\n  return (\r\n    <section>\r\n      <h2>点击按钮查看精彩内容🔥</h2>\r\n      {isShow && (\r\n        <Suspense fallback={<Loading />}>\r\n          <h2>BOOM!</h2>\r\n          <MyComponent />\r\n        </Suspense>\r\n      )}\r\n      <button onClick={() => setIsShow(true)}></button>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n> 参考内容：  \r\n> - [lazy 能够让你在组件第一次被渲染之前延迟加载组件的代码](https://react.docschina.org/reference/react/lazy)  \r\n> - [<Suspense> 允许在子组件完成加载前展示后备方案](https://react.docschina.org/reference/react/Suspense)  \r\n> - [startTransition 可以让你在不阻塞 UI 的情况下更新 state](https://react.docschina.org/reference/react/startTransition)\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 9,
      "path": "public/assets/article/HTTP状态码和缓存.md",
      "author": "quirkybird",
      "title": "HTTP状态码和缓存",
      "categories": "tech_blog",
      "descr": "说说常见的HTTP状态码，以及强制缓存和协商缓存",
      "image": "https://blog.yamorz.top/assets/cover/1701687036856images (1).png",
      "create_at": "2024-10-28",
      "content": "## HTTP 协议\r\n\r\n> HTTP 名为`超文本传输协议`。  \r\n> 更加详细的解释是：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。\r\n\r\n## 五大类 HTTP 状态码\r\n\r\n- `1xx` 提示信息，表示目前是协议处理的中间状态，还需要后续操作\r\n- `2xx` `成功`，报文已成功收到并正确处理\r\n- `3xx` `重定向`，资源位置发生变动，需要客户端重新发送请求\r\n- `4xx` `客户端`错误，请求报文有误，服务器无法处理\r\n- `5xx` `服务器`错误，服务器在处理请求时内部发生错误\r\n\r\n### 常见的一些状态码\r\n\r\n`200`: 一切正常的成功请求  \r\n`204`: 成功请求，响应头没有 body 数据  \r\n`206`: 表示响应 body 返回的是一部分数据，用于断点续传和分块下载\r\n\r\n`301`: 永久重定向，表示资源不在了，需要更换 URL 访问，响应头 Location 指明跳转地址  \r\n`302`: 临时重定向，暂时需要使用另一个 URL 访问，响应头 Location 指明跳转地址  \r\n`304`: 缓存重定向，不具有跳转含义，表示资源未修改，指示资源存在缓存，用于缓存控制\r\n\r\n`400`: 一个笼统的客户端请求错误  \r\n`403`: 表示服务器拒绝客户端请求  \r\n`404`: 表示访问资源不存在或未找到\r\n\r\n`500`: 一个笼统的服务器错错误  \r\n`501`: 表示客户端请求的功能还不支持  \r\n`502`: 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错 误  \r\n`503`: 表示服务器繁忙，暂时无法响应客户端\r\n\r\n## 常见 HTTP 字段\r\n\r\n`Host`、`Content-Length`、`Connection`、`Content-Type`、`Accept`、`Content-Encoding`\r\n\r\n## HTTP 缓存技术\r\n\r\n> 强制缓存和协商缓存\r\n\r\n- 强制缓存  \r\n   使用响应头`Cache-Control`（相对时间）字段和`Expires`（绝对时间）字段  \r\n   使用缓存与否交给浏览器主动控制，判断时间后来直接决定是否使用缓存  \r\n   注意： 如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires**\r\n\r\n- 协商缓存  \r\n  协商缓存就是服务器与客户端协商后决定是否使用本地缓存  \r\n  两种方式实现 - 时间（响应头字段`Last-Modified`和请求头字段`If-Modified-Since`） - 资源唯一标识(响应头字段`If-None-Match`和请求头字段`ETag`)  \r\n  注意：如果两者同时存在，后者（`ETag`）优先级更高\r\n\r\n**强缓存和协商缓存的工作流程图：**\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6646e7a3f5f84e9ba6883dd6613b51e6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 参考资源：[小林 coding](https://xiaolincoding.com/network/2_http/http_interview.html)\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 10,
      "path": "public/assets/article/Event Loop.md",
      "author": "quirkybird",
      "title": "Event Loop",
      "categories": "tech_blog",
      "descr": "js实现不阻塞代码的关键 ——事件循环",
      "image": "https://blog.yamorz.top/assets/cover/1701506095611Event-Loop-browser-V8.png",
      "create_at": "2024-10-28",
      "content": "> 嗯，一个相对复杂的问题。\n\n众所周知，js是一个单线程非阻塞的语言，我们需要使用一个两种模式来执行代码，分为同步模式（**Synchronous**）和异步模式（**Asynchronous**)，异步模式中又有任务队列，任务队列分为宏任务和微任务，事件轮询也就是管理和调度异步任务，宏任务一般是Node和浏览器发起，微任务来自JS本身。  \n\n![代码执行机制](https://img-squad-prod.humandetail.com/inner/20220601rQeMejlR.png)  \n来看看宏任务和微任务都有哪些？\n\n| 宏任务(Macrotask) | 微任务(Microtask) |\n| --- | --- |\n| setTimeout | requestAnimationFrame（有争议） |\n| setInterval | MutationObserver(浏览器环境) |\n| MessageChannel | Promise.[then/catch/finally] |\n| I/O, 事件队列 | process.nextTick(node环境) |\n| setImmediate(node环境) | queueMicrotask |\n| script（整个执行文件） |  |\n\n简而言之，就是当JS代码执行时，每次都会去领取一个宏任务开始，同步任务最先执行完，接着就是本次宏任务下创建的微任务全部执行完，如果是微任务里面又创建了微任务，也会添加到，在下次宏任务开始时，没有任何任务。\n\n直接上题： （以下题目来自于：[【前端体系】从一道面试题谈谈对EventLoop的理解](https://juejin.cn/post/6868849475008331783)）\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(() => {\n\tconsole.log('北歌');\n}, 1 * 2000);\n\nPromise.resolve()\n\t.then(function() {\n\t\tconsole.log('promise1');\n\t}).then(function() {\n\t\tconsole.log('promise2');\n\t});\n\n\nasync function foo() {\n\tawait bar()\n\tconsole.log('async1 end')\n}\nfoo()\n\nasync function errorFunc () {\n\ttry {\n\t\tawait Promise.reject('error!!!')\n\t} catch(e) {\n\t\tconsole.log(e)\n\t}\n\tconsole.log('async1');\n\treturn Promise.resolve('async1 success')\n}\nerrorFunc().then(res => console.log(res))\n\nfunction bar() {\n\tconsole.log('async2 end') \n}\n\nconsole.log('script end');\n\n```\n输出结果：script start、asyn2 end、promise1、async1 end、error!!!、async1、promise2、async1 success、北歌\n```javascript\nconsole.log('1');\n\nsetTimeout(() => {\n  console.log('2');\n  Promise.resolve().then(() => {\n    console.log('3');\n  })\n  new Promise((resolve) => {\n    console.log('4');\n    resolve();\n  }).then(() => {\n    console.log('5')\n  })\n})\n\nPromise.reject().then(() => {\n  console.log('13');\n}, () => {\n  console.log('12');\n})\n\nnew Promise((resolve) => {\n  console.log('7');\n  resolve();\n}).then(() => {\n  console.log('8')\n})\n\nsetTimeout(() => {\n  console.log('9');\n  Promise.resolve().then(() => {\n    console.log('10');\n  })\n  new Promise((resolve) => {\n    console.log('11');\n    resolve();\n  }).then(() => {\n    console.log('12')\n  })\n})\n\n```\n输出结果：1、7、12、8、2、4、3、5、9、11、10、12\n```javascript\nnew Promise((resolve, reject) => {\n  console.log(1)\n  resolve()\n})\n.then(() => { \n  console.log(2)\n  new Promise((resolve, reject) => {\n      console.log(3)\n      setTimeout(() => { \n        reject();\n      }, 3 * 1000);\n      resolve()\n  })\n    .then(() => { \n      console.log(4)\n      new Promise((resolve, reject) => {\n          console.log(5)\n          resolve();\n      })\n        .then(() => { \n          console.log(7)\n        })\n        .then(() => { \n          console.log(9)\n        })\n    })\n    .then(() => { \n      console.log(8)\n    })\n})\n.then(() => { \n  console.log(6)\n})\n\n```\n输出结果：1、2、3、4、5、6、7、8、9\n\n中间还有两道题，先不做了，直接上最复杂的\n```javascript\nasync function async1() {\n  console.log('async1 start');\n  new Promise((resolve, reject) => {\n    try {\n      throw new Error('error1')\n    } catch(e) {\n      console.log(e);\n    }\n    setTimeout(() => { // 宏3\n      resolve('promise4')\n    }, 3 * 1000);\n  })\n    .then((res) => { // 微3-1\n      console.log(res);\n    }, err => {\n      console.log(err);\n    })\n    .finally(res => { // 微3-2 // TODO注3\n      console.log(res);\n    })\n  console.log(await async2()); // 微4-1  TODO-注1\n  console.log('async1 end'); // 微4-2 // TODO-注2\n}\n\nfunction async2() {\n  console.log('async2');\n  return new Promise((resolve) => {\n    setTimeout(() => { // 宏4\n      resolve(2)\n    }, 1 * 3000);\n  })\n}\n\nconsole.log('script start');\n\nsetTimeout(() => { // 宏2\n  console.log('setTimeout');\n}, 0)\n\nasync1();\n\nnew Promise((resolve) => {\n  console.log('promise1');\n  resolve();\n})\n  .then(() => { // 微1-2\n    console.log('promise2');\n    return new Promise((resolve) => {\n      resolve()\n    })\n      .then(() => { // 微1-3\n        console.log('then 1-1')\n      })\n  })\n  .then(() => { // 微1-4\n    console.log('promise3');\n  })\n\n\nconsole.log('script end');\n\n```\n输出结果：script start、async1 start、error1、async2、promise1、script end、peomise2、then 1-1、promise3、settimeout、promise4、undefined、2、async1 end\n\n结合这几个题的练习，对JS的事件轮询就差不多了，来挑战挑战\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 11,
      "path": "public/assets/article/站点安全.md",
      "author": "quirkybird",
      "title": "站点安全",
      "categories": "tech_blog",
      "descr": "XSS、CSRF和SQL注入等常见网站攻击介绍",
      "image": "https://blog.yamorz.top/assets/cover/1702557943811website-attack.png",
      "create_at": "2024-10-28",
      "content": "## XSS攻击（跨站脚本）\n基本定义：XSS 是一个术语，用来描述一类允许攻击者通过网站将客户端脚本代码注入到其他用户的浏览器中的攻击手段。  \n> 例如拿到一个用户的cookie来获得用户个人隐私信息。\n\n通常分为两类：反射型和持久性XSS\n\n- 反射型XSS\n\n反射型 XSS 攻击发生在当传递给服务器的用户数据被立即返回并在浏览器中原样显示的时候——当新页面载入的时候原始用户数据中的任何脚本都会被执行！ 举个例子，假如有个站点搜索函数，搜索项被当作 URL 参数进行编码，这些搜索项将随搜索结果一同显示。攻击者可以通过构造一个包含恶意脚本的搜索链接作为参数（例如 http://mysite.com?q=beer<script%20src=\"http://evilsite.com/tricky.js\"></script>），然后把链接发送给另一个用户。如果目标用户点击了这个链接，当显示搜索结果时这个脚本就会被执行。正如上述讨论的，这促使攻击者获取了所有需要以目标用户进入站点的信息——可能会购买物品或分享联系人信息。\n\n- 持久型 XSS 攻击：\n\n恶意脚本存储在站点中，然后再原样地返回给其他用户，在用户不知情的情况下执行。 举个例子，接收包含未经修改的 HTML 格式评论的论坛可能会存储来自攻击者的恶意脚本。这个脚本会在评论显示的时候执行，然后向攻击者发送访问该用户账户所需的信息。这种攻击类型及其常见而且有效，因为攻击者不需要与受害者有任何直接的接触。 尽管 POST 和 GET 方式获取到的数据是 XSS 攻击最常见的攻击来源，任何来自浏览器的数据都可能包含漏洞（包括浏览器渲染过的 Cookie 数据以及用户上传和显示的文件等）.\n解决方案：防范 XSS 攻击的最好方式就是删除或禁用任何可能包含可运行代码指令的标记。对 HTML 来说，这些包括类似<script>, <object>, <embed>,和 <link> 的标签。\n\n## SQL注入\nSQL 注入漏洞使得恶意用户能够通过在数据库上执行任意 SQL 代码，从而允许访问、修改或删除数据，而不管该用户的权限如何。成功的注入攻击可能会伪造身份信息、创建拥有管理员权限的身份、访问服务器上的任意数据甚至破坏/修改数据使其变得无法使用。\n简单来说就是在本来执行的SQL语句中加入攻击者的SQL，从而操作数据库。\n像是这样\n```sql\nSELECT * FROM users WHERE name = 'a';DROP TABLE users; SELECT * FROM userinfo WHERE 't' = 't';\n```\n本来我们只是想接收一个用户名，然后攻击者通过;,来执行一段它插入的SQL，造成攻击。\n\n解决方案：我们可以对用户输入的特殊字符进行转义，比如对输入的' 或者 &quot;进行转义，让SQL执行时，被认为用户输入的是一个完完全全的字符串。\n```sql\nSELECT * FROM users WHERE name = 'a/';DROP TABLE users; SELECT * FROM userinfo WHERE /'t/' = /'t';\n```\n这样就可以解决SQL注入的风险了。\n\n## 跨站请求伪造（CSRF）\nCSRF 攻击允许恶意用户在另一个用户不知情的情况下利用其身份信息执行操作。\n这个还是比较变态，攻击者伪造一个比如POST请求，放在一个按钮里面，其它一旦点击，就像你在该网站实际操作一样，他就会发起一个请求，比如是转账之类的（当然转账的网站没有这么鸡肋），就完成了这个操作，用户完全不知道他干了什么，就像什么也没有发生，如果服务器要本地的cookie信息，因为是网站用户自己的浏览器，当然储存着这些信息，请求顺利完成。\n解决方案：可以在每次发请求时，由请求的站点生成一个特殊的密钥（网站本身，如果是伪造的，在那个发请求的网站不会生成这样一个密钥，自然就组织了这场交易），验证用户安全。\n\n常见其他攻击：DDos，命令行注入\n\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 12,
      "path": "public/assets/article/伪元素content自定义问题.md",
      "author": "quirkybird",
      "title": "伪元素content自定义问题",
      "categories": "tech_blog",
      "descr": "为什么我的伪元素设置无效，血泪踩坑史",
      "image": "https://blog.yamorz.top/assets/cover/1702887621404Slice 1.png",
      "create_at": "2024-10-28",
      "content": "> 笔者昨天遇到一个伪元素动态设置 content 无效的问题，始终找不到原因，看来前端编程就是靠捣鼓，如果没有解决问题就一直捣鼓，最终还是解决了。\r\n\r\n场景是这样的：我想为我的博客的代码块添加一个显示语言名称的效果，使用代码块伪元素实现，添加到右上角，伪元素的`content`设置为`var(--code-lang)`，检测出语言后，使用 JS 动态设置代码块元素的 CSS 变量`--code-lang`为语言名称,从而实现显示语言名称的效果。\r\n\r\n事实上，上述方案行不通，接下来一起看看历程及解决方案吧。\r\n\r\n首先，设置好代码块`pre`对应的样式，特别是`content: var(--code-lang)`\r\n\r\n```css\r\npre {\r\n  position: relative;\r\n  border-left: 5px solid #b9ccdb;\r\n}\r\npre::after {\r\n  content: var(--code-lang);\r\n  position: absolute;\r\n  right: 10px;\r\n  top: 5px;\r\n  display: inline-block;\r\n  color: #3559e0;\r\n  font-size: clamp(12px 0.4em 16px);\r\n}\r\n```\r\n\r\n我使用`react-markdown`进行的 markdown 渲染，它允许使用 JSX 语法对标签进行自定义渲染，并可以检测语言名称简写，在`className`参数中，例如 JS，得到`language-js`，把 JS 提取出来就好了\r\n\r\n```js\r\n// 组件中有两个全局变量\r\nconst lang = useRef();\r\nconst langList = useRef([]);\r\n// 处理code渲染的函数\r\nconst codeBlock = ({ className, children, node }) => {\r\n  if (className) {\r\n    lang.current = className.split(\"-\")[1].toUpperCase();\r\n    langList.current.push(lang.current);\r\n  }\r\n  return <code>{children}</code>;\r\n};\r\n```\r\n\r\n接下来动态设置好 css 变量`--code-lang`\r\n\r\n```js\r\nuseEffect(() => {\r\n  const codes = document.querySelectorAll(\"pre\");\r\n  const codeBlocks = [...codes];\r\n  for (let index in codeBlocks) {\r\n    // 给每一个代码块对应索引设置好css变量\r\n    codeBlocks[index].style.setProperty(\"--code-lang\", langList.current[index]);\r\n  }\r\n}, []);\r\n```\r\n\r\n好，一切顺利，我们等待奇迹发生(☆▽☆)，然而页面并没有任何显示 😭😭😭，这就奇了怪了，逻辑看起来很通畅啊，于是我 Google，看到一位网友的帖子：[css：伪元素:before 和:after 为什么需要指定一个 content](https://blog.csdn.net/weixin_41981909/article/details/106335340)  \r\n总结起来就是伪元素的 content 必须要有初始值，我一开始设置的`var(--code-lang)`为`undefined`,所以根本没有把::after 设置上\r\n\r\n> 我一开始问的 GPT，它依然告诉我就如此设置，看来 GPT 也无法理解太细的内容，更何况，它经常造一堆根本不存在的 API\r\n\r\n那么问题就来了，我在 pre 中设置一个`--code-lang`的初始值就可以了，对，我的确这样做了，但结果依然不显示结果，在控制台中的确显示了这个变量的正确值，到现在我都不知道怎么回事，知道的朋友欢迎来交流下你的想法  \r\n最后，我还是找到了解决办法就是利用数据属性，具体如下（仅展示核心代码内容）：  \r\n先在渲染代码块时，设置好 data 属性\r\n\r\n```js\r\nconst preEle = ({ children, node }) => {\r\n  return <pre data-after-content=\"\">{children}</pre>;\r\n};\r\n```\r\n\r\n接着，css 设置使用`attr()`CSS 函数，用于访问元素属性\r\n\r\n```css\r\npre::after {\r\n  content: attr(data-after-content);\r\n  //...\r\n}\r\n```\r\n\r\n最后，动态改变`data-after-content`\r\n\r\n```js\r\n//...\r\nfor (let index in codeBlocks) {\r\n  // 先给他们设置上数据属性\r\n  codeBlocks[index].dataset.afterContent = langList.current[index];\r\n}\r\n```\r\n\r\n至此，我们的代码名称可以在右上角正常显示，也就是你现在看到代码块的样子\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 13,
      "path": "public/assets/article/如何实现跨域.md",
      "author": "quirkybird",
      "title": "如何实现跨域",
      "categories": "tech_blog",
      "descr": "什么是跨域？怎么绕开跨域问题？",
      "image": "https://blog.yamorz.top/assets/cover/17027238666311_IsJ26UWXB6WbcXSBUjXniQ.png",
      "create_at": "2024-10-28",
      "content": "什么是跨域： 当协议、域名、端口号有一个不同时，就算跨域。  \n下面三个标签允许跨域：\n\n- `<img src=XXX>`\n- `<link href=XXX>`\n- `<script src=XXX>`\n\n1. JSONP\n\n利用 script 标签是可以跨域请求的特点，不过只能进行 GET 请求  \n日常使用中我们需要封装一个 JSONP\n\n```javascript\n// index.html\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement(\"script\");\n    window[callback] = function (data) {\n      resolve(data);\n      document.body.removeChild(script);\n    };\n    params = { ...params, callback };\n    let arrs = [];\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`);\n    }\n    script.src = `${url}?${arrs.join(\"&\")}`;\n    document.body.appendChild(script);\n  });\n}\njsonp({\n  url: \"http://localhost:3000/say\",\n  params: { wd: \"Iloveyou\" },\n  callback: \"show\",\n}).then((data) => {\n  console.log(data);\n});\n```\n\n```javascript\n// server.js\nlet express = require(\"express\");\nlet app = express();\napp.get(\"/say\", function (req, res) {\n  let { wd, callback } = req.query;\n  res.end(`${callback}('i love you too')`);\n});\napp.listen(3000);\n```\n\n1. CORS\n\n后端 Access-Control-Allow-Origin 响应头字段设置即可，设置通配符\\*可以让所有域名访问，还可以设置特别的域名地址。\n\n3. postMessage()\n\n- 页面和其打开的新窗口的数据传递\n- 多窗口之间消息传递\n- 页面与嵌套的 iframe 消息传递\n\n`otherWindow.postMessage(message, targetOrigin, [transfer]);`\n\n- message: 将要发送到其他 window 的数据。\n- targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"\\*\"（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。\n- transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。\n\n4. websocket（一般使用 socket.io），本省不受同源策略限制\n5. 服务器代理转发\n\n同源策略是浏览器的安全策略，服务器实际上是不受限制的，所以我们可以把浏览器发出的请求在服务器做一次代理请求到另一个服务器，完成请求操作。  \n6.nginx 反向代理\n\n> 最后放一个超厉害的绘图链接[CORS - Cross Origin Resource Sharing](https://securityzines.com/flyers/cors.html)\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 14,
      "path": "public/assets/article/浅拷贝和深拷贝.md",
      "author": "quirkybird",
      "title": "浅拷贝和深拷贝",
      "categories": "tech_blog",
      "descr": "浅拷贝和深拷贝的实现",
      "image": "https://blog.yamorz.top/assets/cover/1703173237271拷贝.png",
      "create_at": "2024-10-28",
      "content": "JS 本身方法的一些拷贝都是浅拷贝，需要深拷贝只有我们自己实现或者使用相关的库(现在的前端从不缺少轮子)，首先了解了解什么浅拷贝和深拷贝吧。\r\n\r\n- **浅拷贝**是指创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。\r\n\r\n- **深拷贝**是指创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝，而不是引用。即无论原始对象的属性是基本类型还是引用类型，都会拷贝一份，互不影响。\r\n\r\n实现浅拷贝很简单，常见的一些方法有：\r\n\r\n1. 使用扩展运算符`...`\r\n\r\n```js\r\nconst obj1 = {\r\n  name: \"quirkybird\",\r\n  age: 21,\r\n  address: {\r\n    city: \"BaZhong\",\r\n  },\r\n};\r\n\r\n// 浅拷贝 obj1\r\nconst obj2 = { ...obj1 };\r\n\r\n// obj1 和 obj2 的 address 属性指向同一个对象\r\nobj1.address.city = \"jinzhou\";\r\n\r\nconsole.log(obj2.address.city); // \"jinzhou\"\r\n```\r\n\r\n2. 使用一些方法  \r\n   `Object.assign()`：将一个或多个对象的属性复制到目标对象上。\r\n   `Array.prototype.slice()`：返回一个新数组，包含原数组的指定部分。\r\n   `Array.prototype.concat()`：将一个或多个数组连接到原数组的末尾。\r\n\r\n深拷贝也有一个简单的方法，就是利用 JOSN 对象\r\n\r\n```js\r\nJSON.parse(JSON.stringify(obj)); //obj为拷贝对象\r\n```\r\n\r\n代码虽然简单，不过却有超多缺点：\r\n\r\n- 效率较低：JSON.stringify() 和 JSON.parse() 都是将对象转换为字符串和从字符串转换为对象的操作，这两个操作都比较耗时。因此，使用 JSON.parse(JSON.stringify(obj)) 进行深拷贝的效率较低\r\n- 可能丢失数据：JSON.stringify() 只能序列化对象的可枚举的自有属性。如果对象中包含不可枚举的属性或属性值为以下类型的值，\r\n  `undefined`、任意的函数以及 `symbol` 值，在序列化过程中会被忽略；\r\n  `Date` 日期会被当做字符串处理；\r\n  `NaN` 和 `Infinity` 格式的数值及 `null` 都会被当做 `null`；\r\n  其他类型的对象，包括 `Map/Set/WeakMap/WeakSet`，仅会序列化可枚举的属性\r\n- 可能导致循环引用：如果对象中存在循环引用，则 JSON.stringify() 将会导致递归调用，可能会导致内存溢出\r\n\r\n最后，让我们试着自己手写一个 deepCopy 吧！  \r\n基本实现:\r\n\r\n```js\r\nconst deepCopy = (obj) => {\r\n  if(obj === null || typeof obj !== \"object\") {\r\n    return obj\r\n  }\r\n\r\n  const newObj = Array.isArray(obj): [] ? {}\r\n\r\n  for(const key in obj) {\r\n    if(obj.hasOwnProperty(key))\r\n    newObj[key] = deepCopy(obj[key])\r\n  }\r\n  return newObj\r\n}\r\n```\r\n\r\n上面版本实现了递归深拷贝，并未判断类型，和解决循环引用  \r\n终极版：\r\n\r\n```js\r\n//判断标识符的类型，是否为Object、Array、function\r\nfunction isObject(value) {\r\n  const valueType = typeof value;\r\n  return (\r\n    valueType !== null && (valueType === \"object\" || valueType === \"function\")\r\n  );\r\n}\r\n\r\n// 深拷贝函数封装\r\nfunction deepCopy(originValue, map = new WeakMap(originValue)) {\r\n  if (!isObject(originValue)) {\r\n    return originValue;\r\n  }\r\n  //   如果是循环引用，则将对象添加到map中\r\n  if (map.has(originValue)) {\r\n    return map.get(originValue);\r\n  }\r\n  // 如果值是Symbol\r\n  if (typeof originValue === \"symbol\") {\r\n    return Symbol(originValue.description);\r\n  }\r\n  // 如果是set类型\r\n  if (originValue instanceof Set) {\r\n    const newSet = new Set();\r\n    for (const setItem of originValue) {\r\n      newSet.add(deepCopy(setItem));\r\n    }\r\n    return newSet;\r\n  }\r\n  // 如果是function\r\n  if (typeof originValue === \"function\") {\r\n    return originValue;\r\n  }\r\n  // 如果是对象类型，则需要创建新的对象\r\n  const newObj = Array.isArray(originValue) ? [] : {};\r\n  for (const key in originValue) {\r\n    //递归实现\r\n    newObj[key] = deepCopy(originValue[key], map);\r\n  }\r\n  //如果是symbol为key值的值\r\n  const symbolKeys = Object.getOwnPropertySymbols(originValue);\r\n  for (const symbolKey of symbolKeys) {\r\n    newObj[Symbol(symbolKey.description)] = deepCopy(\r\n      originValue[symbolKey],\r\n      map\r\n    );\r\n  }\r\n  return newObj;\r\n}\r\n```\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 15,
      "path": "public/assets/article/埋点.md",
      "author": "quirkybird",
      "title": "埋点",
      "categories": "tech_blog",
      "descr": "把用户的数据收集起来然后上传回服务器，方便我们对数据进行分析，再通过可视化技术显示出来。",
      "image": "https://blog.yamorz.top/assets/cover/1702556785238magnifier-5245329_1280.jpg",
      "create_at": "2024-10-28",
      "content": "> 嗯，相对庞大的一块知识  \r\n\r\n在日常的toC项目中，我们通常需要收集用户行为数据，比如他这次访问了哪个页面、点击了哪个按钮、停留时间等，短视频平台比如完播率、浏览量等之类的，都需要把用户的数据收集起来然后上传回服务器，方便我们对数据进行分析，再通过可视化技术显示出来。  \r\n\r\n市面上有一些相当成熟的方案：包括Google Analytics、Mixpanel、Hotjar、Amplitude、Segment、Matomo、百度统计、友盟等。\r\n\r\n下面是一些相关概念\r\n\r\n### UV（Unique visitor）\r\n是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个UV。\r\n### IP（Internet Protocol）\r\n独立IP是指访问过某站点的IP总数，以用户的IP地址作为统计依据。00:00-24:00内相同IP地址之被计算一次。 \r\n\r\n- UV与IP区别\r\n\r\n> 如：你和你的家人用各自的账号在同一台电脑上登录新浪微博，则IP数+1，UV数+2。由于使用的是同一台电脑，所以IP不变，但使用的不同账号，所以UV+2\r\n\r\n### PV（Page View）\r\n即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。\r\n### VV（Visit View）\r\n用以统计所有访客1天内访问网站的次数。当访客完成所有浏览并最终关掉该网站的所有页面时便完成了一次访问，同一访客1天内可能有多次访问行为，访问次数累计。  \r\n\r\nPV与VV区别\r\n\r\n> 如：你今天10点钟打开了百度，访问了它的三个页面；11点钟又打开了百度，访问了它的两个页面，则PV数+5，VV数+2.PV是指页面的浏览次数，VV是指你访问网站的次数。\r\n\r\n我们也可以自己实现一些简单的代码埋点,大概的模式如下：\r\n```js\r\n\r\n// 监听页面加载事件\r\nwindow.addEventListener('load', function() {\r\n  // 发送页面加载时间数据到后端或第三方平台\r\n  reportData('page_load_time', calculatePageLoadTime());\r\n});\r\n\r\n// 监听按钮点击事件\r\ndocument.getElementById('button1').addEventListener('click', function() {\r\n  // 发送按钮点击事件数据到后端或第三方平台\r\n  reportData('button_click', '提交按钮被点击');\r\n});\r\n\r\n// 数据上报函数\r\nfunction reportData(eventType, eventData) {\r\n  // 发送数据到后端或第三方平台的逻辑\r\n  // 可以使用Ajax请求或者其他方式将数据发送到指定的接口\r\n  // 例如：sendDataToBackend(eventType, eventData);\r\n}\r\n```\r\n\r\n> 本文参考：\r\n> [前端埋点系统](https://zhuanlan.zhihu.com/p/493826518)\r\n> [前端埋点实现方案](https://juejin.cn/post/7094146488439144455)",
      "update_at": "2024-03-01"
    },
    {
      "id": 16,
      "path": "public/assets/article/TS的内置类型.md",
      "author": "quirkybird",
      "title": "TS的内置类型",
      "categories": "tech_blog",
      "descr": "一开始使用TS的我，“什么玩意儿，多写这么多代码，ESLint一直报错”，后面切换回JS，怎么vscode这么安静，代码一跑起来，怎么又报错了。",
      "image": "https://blog.yamorz.top/assets/cover/1722356203207typescript-blog-banner.png",
      "create_at": "2024-10-28",
      "content": "一开始使用TS的我，“什么玩意儿，多写这么多代码，ESLint一直报错”，后面切换回JS，怎么vscode这么安静，代码一跑起来，怎么又报错了。  <br />今天来走一遍TS内置类型，让我们的代码更加清晰明了，在执行前编辑器里嘎嘎报错。  \n\n1. Partial (部分的)\n```tsx\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n作用是让传入的属性全部变为可选类型\n> 举个例子\n\n```tsx\ninterface Person {\n  name: string;\n  age: string;\n}\n\nconst one: Person = {}\n\nconst two: Partial<Person> = {}\n```\n![image.png](https://s2.loli.net/2024/07/31/ERjdP9Dy6U5bmZu.png)<br />可以发现two等于一个空对象都不会报错，而one说缺少属性\n\n2. Required (必须的)\n```tsx\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n```\n跟Partial作用是相反的，所有传入类型的属性变为必填\n> 举个例子\n\n```tsx\ninterface Person {\n  name?: string;\n  age?: string;\n}\n\nconst one: Person = {};\n\nconst two: Required<Person> = {};\n\n```\n![image.png](https://s2.loli.net/2024/07/31/7dL9sqlTWafCBMK.png)<br />发现本来可选的，加了Required后，报错必须传入\n\n3. Readonly（只读的）\n```tsx\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n```\n作用是传入类型中所有的属性变为只读的（修改类型报错）\n> 举个例子\n\n```tsx\ninterface Animal {\n  type: string;\n  speed: 'fast' | 'middle' | 'slow';\n}\n\nconst animal1: Readonly<Animal> = { type: '猎豹', speed: 'fast' };\n\nanimal1.speed = 'slow';\n\n```\n![image.png](https://s2.loli.net/2024/07/31/7PDwirjQ3O6VqxE.png)\n\n4. Pick（选择）\n```tsx\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n```\n作用是选择传入类型的部分属性作为新类型\n>  举个例子\n\n```tsx\ninterface Animal {\n  type: string;\n  speed: 'fast' | 'middle' | 'slow';\n  gender: 'male' | 'female';\n}\n\nconst animal: Pick<Animal, 'type' | 'gender'> = { type: '猎豹', speed: 'fast' };\n\n```\n![image.png](https://s2.loli.net/2024/07/31/si93DOMxrwAJS4k.png)<br />可以看到，我们挑选出了`type`和`gender`的联合类型，传入`speed`时, 便会报错\n\n5. Record（记录）\n```tsx\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n```\n构建一个对象类型，其中键、值都有相同类型\n> 举个例子\n\n```tsx\ninterface Animal {\n  type: string;\n  speed: 'fast' | 'middle' | 'slow';\n  gender?: 'male' | 'female';\n}\n\nconst animal: Record<string, Animal> = {\n  animal1: {\n    type: '东北虎',\n    speed: 'fast',\n  },\n  animal2: {\n    type: '企鹅🐧',\n    speed: 'slow',\n  },\n  animal3: ['猫咪', 'middle'],\n};\n\n```\n![image.png](https://s2.loli.net/2024/07/31/n1R3aIrmhVX8BZ9.png)<br />Record决定值的类型为Animal，为一个对象Animal类型，传入不符合就会报错\n\n6. Exclude（排除）\n```tsx\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n```\n排除联合类型中部分属性，不能针对interface（interface用Omit）\n> 举个例子\n\n```tsx\nexport type PersonAttr = 'name' | 'age';\n\nexport type StudentAttr = 'name' | 'age' | 'class' | 'school';\n\nconst student1: Exclude<StudentAttr, PersonAttr> = {name: 'lihua'};\n```\n![image.png](https://s2.loli.net/2024/07/31/lidK9U8mLCXMZoR.png)<br />排除了`name`和`age`\n\n7. Omit（省略）\n```tsx\n/**\n * Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n传入一个对象类型和需要排除的属性类型，组成一个新的类型\n> 举个例子\n\n```tsx\ninterface Animal {\n  type: string;\n  speed: 'fast' | 'middle' | 'slow';\n  gender?: 'male' | 'female';\n}\n\ntype Person = Omit<Animal, 'type' | 'speed'> & { name: string };\n\nconst person1: Person = {\n  name: 'quirkybird',\n  gender: 'male',\n};\n\nconst person2: Person = {\n  name: 'yamorz',\n  gender: 'male',\n  type: 'person',\n};\n\n```\n![image.png](https://s2.loli.net/2024/07/31/MvwQ8icSUIsYEzu.png)<br />被省略后，新类型中不再有`type`和`speed`，无法再添加进对象\n\n除此之外，还有很多类型，`NonNullable`、`Parameters`、`Capitalize`、`Uncapitalize`... ...<br />以上就是列举的部分常见内置类型，有了他们，可以更快速、安全的维护我们的代码，用起来吧🙃\n\n> [TypeScript内置类型一览](https://segmentfault.com/a/1190000041101150)\n\n",
      "update_at": "2024-07-31"
    },
    {
      "id": 17,
      "path": "public/assets/article/20岁进度99.45205479%.md",
      "author": "quirkybird",
      "title": "20岁进度99.45205479%",
      "categories": "life_blog",
      "descr": "这几年都很快，写于我21岁生日前夕",
      "image": "https://blog.yamorz.top/assets/cover/17039676033692023的记号.png",
      "create_at": "2024-10-28",
      "content": "> “风吹那大雪天啊，采呀嘛采头冰啊，采冰的汉子呦，红呀嘛红脸膛啊。”\r\n\r\n![冰车.jpg](https://s2.loli.net/2023/12/31/7ZlGq8IFbeCwEju.jpg)\r\n\r\n昨天是今年我们这冬天的第四次下雪了，也是我两年半的大学时光的最后，今早起床，格外清醒，现在耳边只有楼下同学铲雪的声音，对于睡觉的同学来说，这将是一场噩梦，“呲夸夸”声响回荡在所有宿舍楼间。\r\n\r\n东北的冬天概括说是李雪琴所说的：凛冽！一种酷冷，个个走在路上的行人像刚出炉的包子，都冒着热气儿，冷风呼呼，脸颊有时候都冻地挤不出像样的表情，帽子和手套是必备好物，下雪天总是深一脚浅一脚，日常能看见雪娃娃，雪是很久不会融化的，和夏天的草一样，平铺在土地上。\r\n\r\n没来过东北的人可能还有两个误解，一个是屋里几乎都有暖气，很暖和，和外面完全是两个天，屋外里三层外三层，屋里短袖加短裤，也没那么夸张，温差超级大，第二个是不要相信外边的太阳，这边太阳总是高挂，透过窗户看外边，太阳光肆意的铺洒在大地，给你来一手温柔计，可千万别上它的当，辽宁下雨很少，晴天占大多数，此时太阳只是起到一个照明的作用，真出行还得看本地实时温度来穿衣啊，不然就冻得跟孙子似的。\r\n\r\n日子可真快，悄然从平常的细碎溜过，没有察觉，只是每次回头看，哦，那件事已经是那么久之前的事情了哇，不知道是不是小时候对时间的感知不强，现在明显能察觉一天一天更快了，觉得时间不够用，怎么天又黑了，啊，一天又过去了，躺在床上刷会儿短视频，或者发会儿呆，第二天又开始，重复重复，目前的状态像是被什么东西框住了。\r\n\r\n我爱自然之美，奈何经济暂时不允许我去很远的地方，站在父母的肩膀上，今年，我去了五一假期去了洛阳，感叹曾经 13 朝古都遗迹如今也只有被门票参观，所有的辉煌都有时间限制，龙门石窟去了，对佛教不感兴趣，也不信教，感叹工程的伟大，别无其它，洛阳还去了很多地方。国庆节去爬了泰山、看了青岛的海，凌晨爬上了山顶（南天门，难道这里是天宫），当晚爬山的规模就像是行军打仗，摩肩接踵，到山顶安营扎寨，等待黎明的曙光、随着这趟行程去了青岛，除了没有给我们这帮穷逼准备共享单车外，看到了真正的海，感受脚踩在沙子上，浪花拍打脚踝，夜里站在沙滩上，听自然白噪音，浪打浪，看情侣海边散步闲聊，几个汉子和海浪激情碰撞，我说他们才是“时代弄潮儿”，而我和朋友则在猜飘在海上的那个“果粒橙”塑料瓶子何时才会在岸边停靠。\r\n\r\n今年才放暑假时，我发简书说：“一切的付出将会在明年春天兑现”，春天就快到了，反思自己在过程中，偷懒了至少一半的时间，我就是想做一名前端开发，直接工作，不想考研，不想考公，再过半个月，我就踏上去杭州的路上了，我相信，一切刚刚开始。\r\n\r\n马上 21 岁了，冬天生，冬天长。\r\n\r\nPS: 以上东北指代我的所在地辽宁  \r\n附一张昨天看到的“冰河世纪”\r\n![碎片冰块.jpg](https://s2.loli.net/2023/12/31/e9iHgAValG4twOX.jpg)\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 18,
      "path": "public/assets/article/揭秘移动端像素问题.md",
      "author": "quirkybird",
      "title": "揭秘移动端像素问题",
      "categories": "tech_blog",
      "descr": "最近准备开发一个移动端的小应用，想起来一个问题，手机的尺寸都不一样，如何做到适配的呢？",
      "image": "https://blog.yamorz.top/assets/cover/1706858249776pixel_problem.png",
      "create_at": "2024-10-28",
      "content": "笔者最近准备开发一个移动端的小应用，想起来一个问题，手机的尺寸都不一样，如何做到适配的呢？下面就我查询到关于像素问题资料做一个总结。\r\n主要分为了这么几个概念：`DP`、`DPI`、`DPR`\r\n\r\n**有关像素问题的单位和概念表格如下：**\r\n\r\n| 缩写 | 全称                       | 说明                                                                                           |\r\n| ---- | -------------------------- | ---------------------------------------------------------------------------------------------- |\r\n| PX   | Device Pixels              | 设备像素，指设备的物理像素                                                                     |\r\n| PX   | CSS Pixels                 | CSS 像素，指 CSS 样式代码中使用的逻辑像素                                                      |\r\n| DOT  | Dot                        | 点，屏幕或打印纸上的点，等同物理像素                                                           |\r\n| PT   | Point                      | 磅（传统长度单位）为 1/72 英寸=0.35mm                                                          |\r\n| PT   | iOS Point                  | 磅（iOS 长度单位），为 1/163 英寸，等同于 CSS 逻辑像素                                         |\r\n| DP   | Density independent Pixels | 设备无关像素（Android 长度单位），为 1/160 英寸，等同于 CSS 逻辑像素                           |\r\n| SP   | Scale independent Pixels   | 缩放无关像素（Android 字体单位），等同于 CSS 逻辑像素，但文字尺寸可调（单独缩放）              |\r\n| DPR  | Device Pixel Ratio         | 设备像素比，指 CSS 逻辑像素对于物理像素的倍数                                                  |\r\n| DPPX | Dots Per Pixel             | 等同于 DPR                                                                                     |\r\n| PPI  | Pixel Per Inch             | 屏幕上每英寸(2.54 厘米)的像素点个数                                                            |\r\n| DPI  | Dots Per Inch              | 屏幕或纸上每英寸(2.54 厘米)的点个数，标准密度：传统打印=72；Windows=96；Android=160；iOS=163。 |\r\n| DPIR | DPI Ratio                  | DPI 缩放比例，指 DPI 对于 Windows 标准 DPI 的倍数=DPI/96，等同于 DPR                           |\r\n\r\n> 表格数据来源：[屏幕分辨率基础概念 PX，PT，DP，DPR，DPI 说明](https://www.cnblogs.com/windfic/p/13174010.html)\r\n\r\n关于 DP、DPI、DIP 这几个概念非常混淆，分别来自几篇文章，他们都对其有不同的定义，或许是单词过去过来就那么几个 device、pixel\r\n\r\n> 1. [像素 / 分辨率 / 物理像素和逻辑像素](https://juejin.cn/post/6844904094344151054)  \r\n>    “ 因此将上述设备不能改变的、在设备一生产出来后就确定的像素称作 物理像素 ，也叫 设备像素(device pixels)，简称 dp 。\r\n>    与之对应的用于表示图片尺寸、可时刻改变的像素称作 逻辑像素，也叫 设备独立像素(device independent pixels)，简称 dip 。”\r\n> 2. [揭秘移动端 px,dpi,dpr](https://cloud.tencent.com/developer/article/1842222)  \r\n>    设备像素（dpi）\r\n>    “设备像素（Device Pixels，简写 DP）：又称 物理像素 ，是设备能控制显示的 最小单位 ，我们可以把它看做显示器上的一个点。我们常说的 1920x1080 像素分辨率就是用的 设备像素单位”\r\n\r\n这只是我看到的部分文章，就是因为那几个单词都有`D` `P` `I`,根本不好做定义，不过我们用中文直接说好了\r\n\r\n主要有这么几个应该了解的概念，`物理像素（物理硬件实际的像素点）`、`逻辑像素（又称设备无关像素、设备独立像素、密度无关像素）`、`设备像素比（DPR，这个是统一的）`，那么接下来就具体讲讲如何做到在不同设备上你看到的图像都是一样大的效果，揭开他们神秘的面纱\r\n\r\n先说物理像素，他是我们设备生产出厂时已经确定好的，比如 2340 x 1080, 其实分辨率也就是物理像素高宽像素大小\r\n\r\n其次是逻辑像素，也是上面说的一大堆命名，它们一起决定了设备如何显示呈现的内容，逻辑像素代表了显示内容的一像素占像素点的几个像素\r\n\r\n正常情况下，一个逻辑像素表示一个物理像素，但每个设备不一样的情况下，就不可能刚好逻辑像素 === 物理像素，此时就引出来`DPR（设备像素比）`\r\n它们之间有下面的关系\r\n\r\n> DPR = 物理设备像素 / 逻辑物理像素\r\n\r\n来看一个例子，尺寸相同的两个设备，如果一个是宽度为 375px 的屏幕，一个为宽度为 750px 的屏幕,\r\n现在有一张 200x200 的图片，如果 DPR 同时为 1，这张图片在 750px 的屏幕上会显得特别小，那么我们就要想办法把图片从像素方面着手放大，750 : 375 = 2，如果我们把 750px 的两个物理像素当一个来用，是不是就达到了显示图片一样大的效果，这两个像素就是一个逻辑像素，共同来显示图片的一个像素，水平和垂直方向一共4个像素，此时第二个设备 DPR 等于 2，第二个设备的逻辑像素就和第一个一样了，375px\r\n\r\n**画个图来看看**\r\n\r\n![Logical_pixel and Physical pixel.png](https://s2.loli.net/2024/02/02/yMkr3ughHxEmdqI.png)\r\n\r\n> 注意：像素和手机尺寸没有绝对关系。  \r\n> 手机出厂 DPR 一般也是设置好了的，得到最好的显示效果\r\n\r\n接下来看看在移动端的开发中，如何做到像素动态变化的吧\r\n\r\n`DPI`,\"dots per inch\" 的缩写，“每英寸的像素数”，即像素密度。下图展示了 600 dpi 和 1200 dpi 的对比，明显后者的像素更加密集。\r\n\r\n![v2-323e276f38ee25b395a5d0082f22c542_720w.webp](https://s2.loli.net/2024/02/02/fTVHy1mtjiveDsG.webp)\r\n\r\n安卓手机种类多样，有各种屏幕像素密度。比如 120dpi 是低密度（ldpi）类型，160dpi 是中密度（mdpi），240dpi 是高密度（hdpi)，320dpi 是超高密度（xhdpi），480dpi 是超超高密度（xxhdpi）。\r\n\r\n那现在有很多不同的设备大小，我们如何去画设计图，有没有一个标准呢，想想如果我们还是使用 px 的单位，对不同屏幕像素密度不同的手机，虽然有 DPR 让我们显示大小适宜，但如果尺寸绝对固定，还是有比如尺寸过大的现象，所以我们必须要一个相对单位，适配不同的手机，那就是 dp\r\n\r\n`dp`：Android 开发上的基于屏幕密度的一种密度无关的像素单位，1dp 代表的像素长度=density \\* 1 px\r\n\r\n`density`：屏幕密度，规定以 160dpi 的屏幕其屏幕密度为 1，反过来说就是屏幕密度为 1 的屏幕上 1 英寸上有 160px\r\n\r\n安卓定义 160dpi（dots per inch）的屏幕被视为基准屏幕密度，1dp 等于 1 物理像素。\r\n\r\ndp 与 dpi 有以下关系：px = dp \\*（dpi/160）\r\n\r\n如果我有一个 320dpi 的手机，那么 1dp 就变为了 2px，达到适应不同屏幕的效果\r\n\r\n> 参考文章： [Android 屏幕适配之 dp(最直观的解读)](https://zhuanlan.zhihu.com/p/309758292)  \r\n> PS.上面出现过的链接就不列举了\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 19,
      "path": "public/assets/article/两种图片懒加载的方法.md",
      "author": "quirkybird",
      "title": "两种图片懒加载的方法",
      "categories": "tech_blog",
      "descr": "两种方式告诉你如何实现图片懒加载",
      "image": "https://blog.yamorz.top/assets/cover/17027970469991666020232666.gif",
      "create_at": "2024-10-28",
      "content": "废话不多说，直接进入正题，代码时刻\r\n\r\n1. 利用`Element.getBoundingClientRect`\r\n   该接口主要是获得元素相对于视口的位置，以及元素本身大小，我们可以根据位置信息判断图片所在元素是否出现在了视图中，从而来动态加载图片，我们已经提前把图片的资源地址设置在了`data-src`中,可以利用`imgElement.dataset.src`来获取\r\n\r\n```js\r\nlet imgList = [...document.querySelectorAll(\"img\")];\r\n\r\nconst imgLazyLoad = function () {\r\n  let deleteIndexList = [];\r\n  imgList.forEach((img, index) => {\r\n    let rect = img.getBoundingClientRect();\r\n    if (rect.top < window.innerHeight) {\r\n      img.src = img.dataset.src;\r\n      deleteIndexList.push(index);\r\n    }\r\n  });\r\n  imgList = imgList.filter((img, index) => !deleteIndexList.includes(index));\r\n  //滚动到底部后，移除滚动监听\r\n  if (imgList.length === 0) {\r\n    document.removeEventListener(\"scroll\", imgLazyLoad);\r\n  }\r\n};\r\n\r\ndocument.addEventListener(\"scroll\", imgLazyLoad);\r\n```\r\n\r\n2. 利用`Intersection Observer API`\r\n   其实很类似,使用 intersectionObserver 的实例，使用`observer()`方法来添加每一个元素的观察每一个元素，只要出现在视口中我们就开始加载图片\r\n\r\n```js\r\nconst createObserver = () => {\r\n  const options = {\r\n    // 默认root为null或者不设置，默认为视口\r\n    root: null,\r\n    // 可增加根元素参考边距\r\n    rootMargin: \"0px\",\r\n    // 阈值（目标元素出现内容相对与根元素的百分比）(0-1.0)\r\n    // 1.0意味着元素完全出现在根元素中，才会执行回调函数\r\n    threshold: 0,\r\n  };\r\n\r\n  const observer = new IntersectionObserver(loadImg, options);\r\n  const imgs = document.querySelectorAll(\"img\");\r\n  // 可添加多个观察对象，我们把所有图片元素添加进去\r\n  for (const img of imgs) {\r\n    observer.observe(img);\r\n  }\r\n};\r\n\r\nconst loadImg = (entries, observe) => {\r\n  entries.forEach((entry) => {\r\n    const ele = entry.target;\r\n    // 目标元素进入根元素\r\n    if (entry.isIntersecting && !ele.src) {\r\n      ele.src = ele.dataset.src;\r\n    }\r\n  });\r\n};\r\n// 开启交叉观察\r\ncreateObserver();\r\n```\r\n",
      "update_at": "2024-03-01"
    },
    {
      "id": 20,
      "path": "public/assets/article/CommonJS 和 ES Modules究竟有啥区别.md",
      "author": "quirkybird",
      "title": "CommonJS 和 ES Modules究竟有啥区别?",
      "categories": "tech_blog",
      "descr": "本文探究前端模块化的发展和两种模式的区别，以及ESM为什么好",
      "image": "https://blog.yamorz.top/assets/cover/esmvscjs.png",
      "create_at": "2024-10-28",
      "content": "",
      "update_at": "2024-03-01"
    }
  ]
}
